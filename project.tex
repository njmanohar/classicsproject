
\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{usenix,epsfig,endnotes}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{ifthen}
\usepackage{enumerate}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{color}
\usepackage[lofdepth,lotdepth]{subfig}
\usepackage{tablefootnote}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage{tikz}
\usepackage{hyperref}

\DeclareMathOperator{\Z}{\mathbb{Z}}

\begin{document}

%don't want date printed
\date{}

%make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf Factoring $N = p^2 q$}

%for single author (just remove % characters)
\author{
{\rm Nathan Manohar}\\
\and
{\rm Ben Fisch}\\
% copy the following lines to add more authors
% \and
% {\rm Name}\\
%Name Institution
} % end author

\maketitle

% Use the following at camera-ready time to suppress page numbers.
% Comment it out when you first submit the paper for review.
\thispagestyle{empty}


\subsection*{Abstract}
%Your Abstract Text Goes Here.  Just a few facts.
%Whet our appetites.

We discuss the problem of factoring $N = p^2 q$ and survey some approaches. We then present a specialized factoring algorithm that runs in time $\tilde{O}(q^{1/3})$, which matches the runtime of the factoring algorithm for integers of the form $N = p^r q$ presented in~\cite{dan}. Furthermore, we determine the number of advise bits needed by our algorithm to factor $p^2 q$ in polynomial time and compare this with the number of bits needed by~\cite{dan}. Finally, we discuss the possibility of constructing cryptographic primitives from the assumption that $p^2 q$ is hard to factor. We present our attempt at constructing key agreement and discuss the difficulties of building this primitive from the hardness of factoring $p^2 q$.

\section{Introduction and Problem Overview}

The problem of factoring $p^2 q$ is of considerable interest in cryptography. Various encryption schemes, such as the EPOC cryptosystem~\cite{Okamoto} and the ESIGN digital signature scheme~\cite{esign}, are based on the assumption that this problem is hard to solve. Furthermore, Takagai~\cite{Takagai} showed that RSA decryption can be made much faster when moduli of the form $N = p^r q$ or, in particular, $N = p^2 q$ are used. A natural question to ask is whether factoring $p^2q$ is as hard as factoring a general RSA modulus $N = pq$. In particular, is there a way to exploit the fact that $N$ is of the form $p^2q$ that could lead to an improvement in factoring moduli of this form? 

One observation is that given $N = p^2q$, it is easy to learn if $q$ is a quadratic residue modulo some prime $\ell$. To see this, we first note that the Jacobi symbol $\left(\frac{\ell}{N}\right)$ is computable in polynomial time via repeated application of the law of quadratic reciprocity. Additionally, since the Jacobi symbol is a multiplicative function, it follows that
\[
\left(\frac{\ell}{N}\right) = \left(\frac{\ell}{p^2q}\right) = \left(\frac{\ell}{p^2}\right) \left(\frac{\ell}{q}\right) = \left(\frac{\ell}{p}\right)^2 \left(\frac{\ell}{q}\right).
\]

Since $\text{gcd}(\ell,p) = 1$ (for $\ell \ne p$), it follows that the Legendre symbol $\left(\frac{\ell}{p}\right) = \pm 1$ and therefore
\[
\left(\frac{\ell}{N}\right) = \left(\frac{\ell}{q}\right).
\]
By the law of quadratic reciprocity, it follows that
\[
\left(\frac{\ell}{q}\right) \left(\frac{q}{\ell}\right) = (-1)^{\frac{\ell-1}{2} \frac{q-1}{2}}, 
\]
and so $\left(\frac{q}{\ell}\right)$ can be computed in polynomial time.

One approach to factoring $p^2 q$ is to attempt to leverage the information about $q$'s quadratic residuosity to recover $q$. In Section {\color{red} INSERT SECTION NUMBER}, we present a $\tilde{O}(q^{1/3})$ time factoring algorithm for $p^2 q$ that follows this approach. Furthermore, we consider the problem of factoring $p^2 q$ given some bits of advice and show that our algorithm can factor $p^2 q$ in polynomial time given {\color{red} INSERT NUMBER} advice bits. 

In Section~\ref{prq}, we survey a specialized factoring algorithm for numbers of the form $p^r q$ due to Boneh, Durfee, and Howgrave-Graham~\cite{dan}. They show that when given a good enough approximation $P$ to $p$, it is possible to recover $p$ in polynomial time by constructing a polynomial $f$ with small coefficients that has $x = p - P$ as a root. If the coefficients of the polynomial are sufficiently small and the root $x$ is also sufficiently small, they show that there will be no wrap-around and $x$ will be a root of $f$ over the integers, which can be recovered in polynomial time. The required approximation $P$ to $p$ is found via brute force and this process determines the running time of the algorithm since the rest of it runs in polynomial time. If the required approximation $P$ to $p$ can be found in polynomial time, then this algorithm runs in polynomial time, which~\cite{dan} shows to be the case when $r = \Omega(\log p)$. For factoring $p^2 q$, this algorithm has a running time of $\tilde{O}(p^{1/3})$, which matches the time complexity of our factoring algorithm (assuming the factors $p$ and $q$ are of roughly the same size). Additionally, this algorithm requires $\frac{\log p}{3} + O(1)$ advice bits to factor $p^2 q$ in polynomial time~\cite{dan}. 

These two algorithms provide interesting approaches to factoring $p^2 q$ and could potentially be improved to reduce their running times. However, these two algorithms are currently eclipsed asymptotically by general purpose factoring algorithms such as the Elliptic Curve Method~\cite{Lenstra} and the Number Field Sieve~\cite{pomerance}.  

Since factoring $p^2 q$ appears to be quite difficult, we also approach this problem in the other direction where we assume it is hard to solve and try to construct cryptographic primitives from this assumption. In Section {\color{red} INSERT SECTION NUMBER}, we show our attempt at constructing key agreement from this assumption and discuss the difficulties of making such a construction work. 

We conclude by discussing the variety of open problems related to factoring $p^2 q$ and describe directions for future work.




\section{One Approach}


One approach to factoring $p^2 q$ is to attempt to use the information about $q$'s quadratic residuosity modulo many primes $\ell_i$ to construct a polynomial that must have $q$ as a small root and then determine this root using Coppersmith's method~\cite{Coppersmith}. 

As discussed previously, it is possible given $N = p^2 q$ and some prime $\ell$ to compute $\left(\frac{q}{\ell}\right)$ in polynomial time. Using this information, we can construct tables $T_{\ell_i}$ for primes $\ell_i$ that list the possible values of $q \bmod \ell_i$. Since there are $\frac{\ell_i - 1}{2}$ quadratic residues and nonresidues modulo $\ell_i$, the size of $T_{\ell_i}$ will be $\frac{\ell_i - 1}{2}$. Equivalently, let $b_i =  \left(\frac{q}{\ell_i}\right)$. Then, the table $T_{\ell_i}$ contains the roots of the polynomial $(x^{(\ell_i - 1)/2} - b_i)$ over $\mathbb{Z}_{\ell_i}$. The question of factoring $p^2 q$ has now been reduced to the question of whether $q$ can be efficiently reconstructed given information about whether or not $q$ is a quadratic residue modulo primes for a fixed sequence of primes. 

Observe that for each prime $\ell_i$ for which we have a corresponding table $T_{\ell_i}$, we can construct the polynomial
\[
f_{\ell_i}(x) = \prod_{a \in T_{\ell_i}} (x - a) \bmod \ell_i.
\]

Then, using the Chinese remainder theorem, we can construct the polynomial $f \bmod \prod_i \ell_i$ obtained by applying to the Chinese remainder theorem term-wise to the coefficients of each of the $f_{\ell_i}$'s. Note that since $q$ is a root of all the $f_{\ell_i}$'s, it follows that $q$ is a root of $f$. However, $q$ is not a sufficiently small root of $f$ for Coppersmith's algorithm to determine it. In particular, if $f$ is a polynomial of degree $d$ modulo $L$, Coppersmith's algorithm will only find roots that are $< L^{1/d}$. However, if the $\ell_i$'s are the first $n$ primes, then $\prod_i \ell_i \approx e^n$. Since we must have $\prod_i \ell_i > q$, it follows that we need $n > \ln q$. Additionally, we note that the degree of $f$ will be the size of the largest table, which will be $\frac{\ell_n - 1}{2}$. Since the size of the largest prime is $\approx n \ln n$, it follows that $L^{1/d}$ will be approximately
\[
e^{2n/n\ln n} = e^{2/\ln n} = e^{O(1/\log \log q)}  << q,
\]  
and so Coppersmith's method will not be able to determine $q$.

An immediate observation is that if the degree of $f$ was smaller (was $n^{1 - \varepsilon}$ instead of $\approx n \ln n$), then Coppersmith's method would be sufficient to determine $q$. In this case, we would have that $L^{1/d}$ is $\approx e^{n^{\varepsilon}} > q$ for $n = O(\log^{1/\varepsilon} q)$. However, there does not seem to be any way to reduce the degree using these tables alone. In particular, since the size of the tables is $O(n \ln n)$, $f$ must necessarily have degree $O(n \ln n)$ in order to capture all the possible values of $q$. If some extra information about $q$ unrelated to the quadratic residuosity of $q$ modulo primes could be gathered, this could potentially be leveraged to reduce the size of the tables. 

\section{Factoring $N = p^rq$}
\label{prq}

Due to prevalence of moduli of the form $N = p^r q$ in cryptography, researchers have studied the difficulty of factoring moduli of this special form. In~\cite{dan}, Boneh, Durfee, and Howgrave-Graham present a method for factoring integers of the form $N = p^r q$ that utilizes techniques introduced by Coppersmith in~\cite{Coppersmith1997}. However, this method only runs in polynomial time (in $\log N$) when $r = \Omega(\log p)$. When $r = 2$, this method runs in time $\tilde{O}(p^{1/3})$, which is slower than the Elliptic Curve Method~\cite{Lenstra} or the Number Field Sieve~\cite{pomerance}. When $r \approx \sqrt{\log p}$, this lattice-based factoring method begins to be asymptotically faster than the Elliptic Curve Method and the Number Field Sieve. This method is particularly interesting because it runs in polynomial time if it is provided with a good enough approximation to $p$. For the case of $N = p^2 q$, this lattice-based method will factor $N$ in polynomial time given the most significant third of the bits of $p$. Since this method has a similar asymptotic running time to our factoring algorithm, we present a sketch of the algorithm here for completeness.

For simplicity, we will only describe the algorithm for the case $r = 2$, but the process described below easily extends to larger $r$. Additionally, we will try to follow the notation used in~\cite{dan}. At a high level, the algorithm is based on the following idea. Suppose that some rough approximation $P$ to $p$ is known. In particular, suppose $|P - p| < X$ for some $X$ to be determined. Then, if one considers the polynomial
\[
f(x) = (P + x)^2,
\]  
it follows that the point $x_0 = p - P$ is a root of $f(x) \bmod p^2$. Furthermore, since $P$ was a good approximation to $p$, it follows that $|x_0| < X$. So, the problem has been reduced to finding a small root of $f(x) \bmod p^2$. It is important to point out here that the modulus in question, $p^2$ is unknown. However, knowing the modulus becomes unnecessary given the following fact due to Howgrave-Graham: Suppose that $f(x)$ is a degree $d$ polynomial over the integers. Suppose further that $f(x_0) \equiv 0 \bmod p^s$ for some small root $|x_0| < X$ and that $||f(xX)|| < p^s/\sqrt{d}$, where $||f||$ is defined as the $\ell_2$ norm of its coefficients vector. Then, $f(x_0) = 0$ in $\Z$. 

The above essentially states that if we can construct a polynomial with sufficiently small coefficients, then $x_0$ will be a root over the integers, which can be found in polynomial time. We note that knowing the modulus $p^2$ or $p^s$ is unnecessary. All that we need to be able to do is to construct a polynomial that has small coefficients when evaluated on $xX$ while maintaining the fact that the polynomial has a root at $x_0$ modulo $p^s$. 

To accomplish this,~\cite{dan} sets $s = 2m$ for some parameter $m$ to be determined and takes a series of polynomials $g_{i,k}(x)$ that are constructed so that $x_0 = p - P$ is a root modulo $p^{2m}$. They then construct a lattice $\mathcal{L}$ whose basis is the set of coefficients vectors of the $g_{i,k}(xX)$'s. Using the LLL algorithm~\cite{LLL}, it is then possible to find a short vector $\bf{v} \in \mathcal{L}$. This short vector $\bf{v}$ can be thought of as the coefficients vector of a new polynomial $h(xX)$. However, since $\bf{v} \in \mathcal{L}$, $h(x)$ can be expressed as a linear combination of the $g_{i,k}$'s and since $g_{i,k}(x_0) \equiv 0 \bmod p^{2m}$ for all $g_{i,k}$, it follows that $h(x_0) \equiv 0 \bmod p^{2m}$. Therefore as stated previously (provided that $||h(xX)||$ is sufficiently small), $x_0$ is a root of $h$ over the integers and can therefore be found in polynomial time. Since $x_0 = p-P$ and $P$ is public, it is then possible to recover $p$ and factor $N = p^2 q$. 

More specifically, the polynomials $g_{i,k}$ are defined as
\[
g_{i,k}(x) = N^{m-k}x^i f^k(x)
\]
where $f^k(x) = (P+x)^{2k}$. We note immediately that
\begin{align*}
g_{i,k}(x_0) &= (p^2q)^{m-k} x^i (P + p - P)^{2k} \\
&= p^{2m}q^{m-k}x^i \\
&\equiv 0 \bmod p^{2m}
\end{align*}
and so $x_0$ is a root of $g_{i,k} \bmod p^{2m}$ for all $i,k$. 

The LLL algorithm guarantees that when given a full rank lattice $\mathcal{L}$ of dimension $d$ as input, it will output a lattice vector $\bf{v}$ such that
\[
||\textbf{v}|| \leq 2^{d/2} \det(L)^{1/d}
\]
where $L$ is the matrix whose column vectors form a basis of $\mathcal{L}$. The lattice $\mathcal{L}$ is instantiated to be the lattice whose basis vectors are the coefficients vectors of the polynomials $g_{i,k}(xX)$ for $i = 0,1$ and $k = 0, \hdots, m-1$ and the coefficient vectors of the polynomials $g_{j,m}(xX)$ for $j = 0, \hdots, d - 2m - 1$. $\mathcal{L}$ is a $d$-dimensional lattice and the matrix $L$ corresponding to this lattice is triangular, so its determinant can be easily computed as the product of the diagonal entries. After some calculation,~\cite{dan} determines that
\[
\det(L) < N^{m(m+1)}X^{d^2/2}
\] 
and therefore, the LLL algorithm will output a vector $\textbf{v}$ satisfying
\[
||\textbf{v}|| \leq 2^{d/2} N^{m(m+1)/d}X^{d/2}.
\]
Viewing $\textbf{v}$ as the coefficients vector of some polynomial $h(xX)$, we see that the algorithm can determine $p$ provided
\[
||h(xX)|| < \frac{p^{2m}}{\sqrt{d}}.
\]
It remains to determine optimal values for the parameters $X, m, d$. It can be shown that the optimal value for $m$ is
\[
m = \lfloor \frac{d}{3} - \frac{1}{2} \rfloor.
\]
The algorithm will then succeed provided that 
\[
X < p^{2/3 - 4/d}.
\]
Since the LLL algorithm runs in time polynomial in the dimension $d$ of the lattice~\cite{LLL}, we can choose $d = O(\log p)$ and still have one iteration of the factoring algorithm run in polynomial time. 

All that remains is to determine $P$. This can be done by iterating through all possible values of the most significant bits of $p$, where the number of bits we need to guess is determined by the precision of the approximation required. For factoring $N = p^2 q$, we need to correctly guess one third of the bits of $p$ (plus an additional constant number of bits which can be brute forced at each step without increasing the asymptotic running time). There are $p^{1/3}$ possibilities for the most significant third of the bits of $p$, and so it follows that this algorithm factors $p^2 q$ in time $\tilde{O}(p^{1/3})$.

A interesting property of this algorithm is that it can be easily made to run in polynomial time given a sufficient number of advice bits. In particular, given a close enough approximation $P$ to $p$, the algorithm can determine $p$ in polynomial time. For factoring $p^2 q$, the most significant third of the bits of $p$ or $\frac{\log p}{3}$ advice bits are needed for the algorithm to run in polynomial time.

\section{General Purpose Factoring Algorithms}



\section{Beyond Coppersmith's method} 
Given that Coppersmith's method will not work for finding sufficiently many roots (i.e., more than constant size roots) of a polynomial of degree $O(\log(N))$ over $N$, we need to search for other methods. Define $K = p_1 \cdots p_k$ such that $q < K$. Define $N = p_1 \cdots p_n$ for $n > k$. As before, let $F$ be the unique polynomial mod N that is equivalent to $f_i = (x^{(p_i - 1)/2} - b_i)$ over $\mathbb{Z}_{p_i}$ where $b_i =  \left(\frac{q}{p_i}\right)$. The first question is whether we can even hope that there will be a small (i.e. polynomial) number of roots of $F$ that are less than $K$, otherwise there would probably be no hope of recovering $q$. When $n = k$ it is easy to see that there are an exponential number of roots in $[0, K)$ because any k-wise combination of the roots of $f_i$ for each $i$ corresponds to a unique integer in $\mathbb{Z}_k$ that is a root of $F$. This total number of roots is precisely $\Pi_{i= 1}^k (p_i - 1)/2 \approx K/2^k$. Although the number of solutions for $q$ remaining is still exponential, the information about $q$ that we got from examining the roots of $f_1,...,f_k$ reduced the solution space by a factor $2^k$. Heuristically, we would hope that each polynomial $f_i$ for $i > k$ would continue to reduce the solution space by a factor 2 so that we would only need $n = O(k) = O(log(q))$ polynomials to reduce the number of solutions to a constant. However, proving this seems to be tricky and we are working on a proof. 

\section{Turning the Problem Around} 
Another idea we are working on is to turn this problem around and assume it is hard to factor $p^2q$, and thus that it is hard to find small roots of polynomials of poly degree over a super smooth modulus N and to build some useful crypto primitives like key exchange from this assumption. This problem may also be quantum hard. 

\section{Conclusions and Open Problems}




{\footnotesize \bibliographystyle{acm}
\bibliography{project}}


%\theendnotes

\end{document}
