
\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{usenix,epsfig,endnotes}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{ifthen}
\usepackage{enumerate}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{color}
\usepackage[lofdepth,lotdepth]{subfig}
\usepackage{tablefootnote}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage{tikz}
\usepackage{hyperref}

\DeclareMathOperator{\Z}{\mathbb{Z}}

\begin{document}

%don't want date printed
\date{}

%make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf Factoring $N = p^2 q$}

%for single author (just remove % characters)
\author{
{\rm Nathan Manohar}\\
\and
{\rm Ben Fisch}\\
% copy the following lines to add more authors
% \and
% {\rm Name}\\
%Name Institution
} % end author

\maketitle

% Use the following at camera-ready time to suppress page numbers.
% Comment it out when you first submit the paper for review.
\thispagestyle{empty}


\subsection*{Abstract}
%Your Abstract Text Goes Here.  Just a few facts.
%Whet our appetites.

We discuss the problem of factoring $N = p^2 q$ and survey some approaches. We then present a specialized factoring algorithm that runs in time $\tilde{O}(q^{1/3})$, which matches the runtime of the factoring algorithm for integers of the form $N = p^r q$ presented in~\cite{dan}. Furthermore, we determine the number of advise bits needed by our algorithm to factor $p^2 q$ in polynomial time and compare this with the number of bits needed by~\cite{dan}. Finally, we discuss the possibility of constructing cryptographic primitives from the assumption that $p^2 q$ is hard to factor. We present our attempt at constructing key agreement and discuss the difficulties of building this primitive from the hardness of factoring $p^2 q$.

\section{Introduction and Problem Overview}

The problem of factoring $p^2 q$ is of considerable interest in cryptography. Various encryption schemes, such as the EPOC cryptosystem~\cite{Okamoto}, are based on the assumption that this problem is hard to solve. A natural question to ask is whether factoring $p^2q$ is as hard as factoring a general RSA modulus $N = pq$. In particular, is there a way to exploit the fact that $N$ is of the form $p^2q$ that could lead to an improvement in factoring moduli of this form? One observation is that given $N = p^2q$, it is easy to learn if $q$ is a quadratic residue modulo some prime $\ell$. To see this, we first note that the Jacobi symbol $\left(\frac{\ell}{N}\right)$ is computable in polynomial time via repeated application of the law of quadratic reciprocity. Additionally, since the Jacobi symbol is a multiplicative function, it follows that
\[
\left(\frac{\ell}{N}\right) = \left(\frac{\ell}{p^2q}\right) = \left(\frac{\ell}{p^2}\right) \left(\frac{\ell}{q}\right) = \left(\frac{\ell}{p}\right)^2 \left(\frac{\ell}{q}\right).
\]

Since $\text{gcd}(\ell,p) = 1$ (for $\ell \ne p$), it follows that the Legendre symbol $\left(\frac{\ell}{p}\right) = \pm 1$ and therefore
\[
\left(\frac{\ell}{N}\right) = \left(\frac{\ell}{q}\right).
\]
By the law of quadratic reciprocity, it follows that
\[
\left(\frac{\ell}{q}\right) \left(\frac{q}{\ell}\right) = (-1)^{\frac{\ell-1}{2} \frac{q-1}{2}}, 
\]
and so $\left(\frac{q}{\ell}\right)$ can be computed in polynomial time.

Using this information, we can construct tables $T_{\ell_i}$ for primes $\ell_i$ that list the possible values of $q \bmod \ell_i$. Since there are $\frac{\ell_i - 1}{2}$ quadratic residues and nonresidues modulo $\ell_i$, the size of $T_{\ell_i}$ will be $\frac{\ell_i - 1}{2}$. Equivalently, let $b_i =  \left(\frac{q}{\ell_i}\right)$ then the table $T_{\ell_i}$ contains the roots of the polynomial $(x^{(\ell_i - 1)/2} - b_i)$ over $\mathbb{Z}_{\ell_i}$. The question of factoring $p^2 q$ has now been reduced to the question of whether $q$ can be efficiently reconstructed given information about whether or not $q$ is a quadratic residue modulo primes for a fixed sequence of primes. 

\section{One Approach}

One approach to factoring $p^2 q$ is to attempt to construct a polynomial that must have $q$ as a small root and then determine this root using Coppersmith's method~\cite{Coppersmith}. Observe that for each prime $\ell_i$ for which we have a corresponding table $T_{\ell_i}$, we can construct the polynomial
\[
f_{\ell_i}(x) = \prod_{a \in T_{\ell_i}} (x - a) \bmod \ell_i.
\]

Then, using the Chinese remainder theorem, we can construct the polynomial $f \bmod \prod_i \ell_i$ obtained by applying to the Chinese remainder theorem term-wise to the coefficients of each of the $f_{\ell_i}$'s. Note that since $q$ is a root of all the $f_{\ell_i}$'s, it follows that $q$ is a root of $f$. However, $q$ is not a sufficiently small root of $f$ for Coppersmith's algorithm to determine it. In particular, if $f$ is a polynomial of degree $d$ modulo $L$, Coppersmith's algorithm will only find roots that are $< L^{1/d}$. However, if the $\ell_i$'s are the first $n$ primes, then $\prod_i \ell_i \approx e^n$. Since we must have $\prod_i \ell_i > q$, it follows that we need $n > \ln q$. Additionally, we note that the degree of $f$ will be the size of the largest table, which will be $\frac{\ell_n - 1}{2}$. Since the size of the largest prime is $\approx n \ln n$, it follows that $L^{1/d}$ will be approximately
\[
e^{2n/n\ln n} = e^{2/\ln n} = e^{O(1/\log \log q)}  << q,
\]  
and so Coppersmith's method will not be able to determine $q$.

An immediate observation is that if the degree of $f$ was smaller (was $n^{1 - \varepsilon}$ instead of $\approx n \ln n$), then Coppersmith's method would be sufficient to determine $q$. In this case, we would have that $L^{1/d}$ is $\approx e^{n^{\varepsilon}} > q$ for $n = O(\log^{1/\varepsilon} q)$. However, there does not seem to be any way to reduce the degree using these tables alone. In particular, since the size of the tables is $O(n \ln n)$, $f$ must necessarily have degree $O(n \ln n)$ in order to capture all the possible values of $q$. If some extra information about $q$ unrelated to the quadratic residuosity of $q$ modulo primes could be gathered, this could potentially be leveraged to reduce the size of the tables. 

\section{Factoring $N = p^rq$}

Due to prevalence of moduli of the form $N = p^r q$ in cryptography, researchers have studied the difficulty of factoring moduli of this special form. In~\cite{dan}, Boneh, Durfee, and Howgrave-Graham present a method for factoring integers of the form $N = p^r q$ that utilizes techniques introduced by Coppersmith in~\cite{Coppersmith1997}. However, this method only runs in polynomial time (in $\log N$) when $r = O(\log p)$. When $r = 2$, this method runs in time $\tilde{O}(p^{1/3})$, which is slower than the Elliptic Curve Method~\cite{Lenstra} or the Number Field Sieve~\cite{pomerance}. When $r = O(\sqrt{\log p})$, this lattice-based factoring method begins to be asymptotically faster than the Elliptic Curve Method and the Number Field Sieve. This method is particularly interesting because it runs in polynomial time if it is provided with a good enough approximation to $p$. For the case of $N = p^2 q$, this lattice-based method will factor $N$ in polynomial time given the most significant third of the bits of $p$. Since this method has a similar asymptotic running time to our factoring algorithm, we present a sketch of the algorithm here for completeness.

For simplicity, we will only describe the algorithm for the case $r = 2$, but the process described below easily extends to larger $r$. Additionally, we will try to follow the notation used in~\cite{dan}. At a high level, the algorithm is based on the following idea. Suppose that some rough approximation $P$ to $p$ is known. In particular, suppose $|P - p| < X$ for some $X$ to be determined. Then, if one considers the polynomial
\[
f(x) = (P + x)^2,
\]  
it follows that the point $x_0 = p - P$ is a root of $f(x) \bmod p^2$. Furthermore, since $P$ was a good approximation to $p$, it follows that $|x_0| < X$. So, the problem has been reduced to finding a small root of $f(x) \bmod p^2$. It is important to point out here that the modulus in question, $p^2$ is unknown. However, knowing the modulus becomes unnecessary given the following fact due to Howgrave-Graham: Suppose that $f(x)$ is a degree $d$ polynomial over the integers. Suppose further that $f(x_0) \equiv 0 \bmod p^s$ for some small root $|x_0| < X$ and that $||f(xX)|| < p^s/\sqrt{d}$, where $||f||$ is defined as the $\ell_2$ norm of its coefficients vector. Then, $f(x_0) = 0$ in $\Z$. 

The above essentially states that if we can construct a polynomial with sufficiently small coefficients, then $x_0$ will be a root over the integers, which can be found in polynomial time. We note that knowing the modulus $p^2$ or $p^s$ is unnecessary. All that we need to be able to do is to construct a polynomial that has small coefficients when evaluated on $xX$ while maintaining the fact that the polynomial has a root at $x_0$ modulo $p^s$. 

To accomplish this,~\cite{dan} sets $s = 2m$ for some parameter $m$ to be determined and takes a series of polynomials $g_{i,k}(x)$ that are constructed so that $x_0 = p - P$ is a root modulo $p^{2m}$. They then construct a lattice $\mathcal{L}$ whose basis is the set of coefficients vectors of the $g_{i,k}(xX)$'s. Using the LLL algorithm~\cite{LLL}, it is then possible to find a short vector $\bf{v} \in \mathcal{L}$. This short vector $\bf{v}$ can be thought of as the coefficients vector of a new polynomial $h(xX)$. However, since $\bf{v} \in \mathcal{L}$, $h(x)$ can be expressed as a linear combination of the $g_{i,k}$'s and since $g_{i,k}(x_0) \equiv 0 \bmod p^{2m}$ for all $g_{i,k}$, it follows that $h(x_0) \equiv 0 \bmod p^{2m}$. Therefore as stated previously (provided that $||h(xX)||$ is sufficiently small), $x_0$ is a root of $h$ over the integers and can therefore be found in polynomial time. Since $x_0 = p-P$ and $P$ is public, it is then possible to recover $p$ and factor $N = p^2 q$. 

More specifically, the polynomials $g_{i,k}$ are defined as
\[
g_{i,k}(x) = N^{m-k}x^i f^k(x)
\]
where $f^k(x) = (P+x)^{2k}$. We note immediately that
\begin{align*}
g_{i,k}(x_0) &= (p^2q)^{m-k} x^i (P + p - P)^{2k} \\
&= p^{2m}q^{m-k}x^i \\
&\equiv 0 \bmod p^{2m}
\end{align*}
and so $x_0$ is a root of $g_{i,k} \bmod p^{2m}$ for all $i,k$. 

The LLL algorithm guarantees that when given a full rank lattice $\mathcal{L}$ of dimension $d$ as input, it will output a lattice vector $\bf{v}$ such that
\[
||\textbf{v}|| \leq 2^{d/2} \det(L)^{1/d}
\]
where $L$ is the matrix whose column vectors form a basis of $\mathcal{L}$. The lattice $\mathcal{L}$ is instantiated to be the lattice whose basis vectors are the coefficients vectors of the polynomials $g_{i,k}(xX)$ for $i = 0,1$ and $k = 0, \hdots, m-1$ and the coefficient vectors of the polynomials $g_{j,m}(xX)$ for $j = 0, \hdots, d - 2m - 1$. $\mathcal{L}$ is a $d$-dimensional lattice and the matrix $L$ corresponding to this lattice is triangular, so its determinant can be easily computed as the product of the diagonal entries. After some calculation,~\cite{dan} determines that
\[
\det(L) < N^{m(m+1)}X^{d^2/2}
\] 
and therefore, the LLL algorithm will output a vector $\textbf{v}$ satisfying
\[
||\textbf{v}|| \leq 2^{d/2} N^{m(m+1)/d}X^{d/2}.
\]
Viewing $\textbf{v}$ as the coefficients vector of some polynomial $h(xX)$, we see that the algorithm can determine $p$ provided
\[
||h(xX)|| < \frac{p^{2m}}{\sqrt{d}}.
\]
It remains to determine optimal values for the parameters $X, m, d$. It can be shown that the optimal value for $m$ is
\[
m = \lfloor \frac{d}{3} - \frac{1}{2} \rfloor.
\]
The algorithm will then succeed provided that 
\[
X < p^{2/3 - 4/d}.
\]
Since the LLL algorithm runs in time polynomial in the dimension $d$ of the lattice~\cite{LLL}, we can choose $d = O(\log p)$ and still have one iteration of the factoring algorithm run in polynomial time. 

All that remains is to determine $P$. This can be done by iterating through all possible values of the most significant bits of $p$, where the number of bits we need to guess is determined by the precision of the approximation required. For factoring $N = p^2 q$, we need to correctly guess one third of the bits of $p$ (plus an additional constant number of bits which can be brute forced at each step without increasing the asymptotic running time). There are $p^{1/3}$ possibilities for the most significant third of the bits of $p$, and so it follows that this algorithm factors $p^2 q$ in time $\tilde{O}(p^{1/3})$.

A interesting property of this algorithm is that it can be easily made to run in polynomial time given a sufficient number of advice bits. In particular, given a close enough approximation $P$ to $p$, the algorithm can determine $p$ in polynomial time. For factoring $p^2 q$, the most significant third of the bits of $p$ or $\frac{\log p}{3}$ advice bits are needed for the algorithm to run in polynomial time.

\section{General Purpose Factoring Algorithms}



\section{Beyond Coppersmith's method} 
Given that Coppersmith's method will not work for finding sufficiently many roots (i.e., more than constant size roots) of a polynomial of degree $O(\log(N))$ over $N$, we need to search for other methods. Define $K = p_1 \cdots p_k$ such that $q < K$. Define $N = p_1 \cdots p_n$ for $n > k$. As before, let $F$ be the unique polynomial mod N that is equivalent to $f_i = (x^{(p_i - 1)/2} - b_i)$ over $\mathbb{Z}_{p_i}$ where $b_i =  \left(\frac{q}{p_i}\right)$. The first question is whether we can even hope that there will be a small (i.e. polynomial) number of roots of $F$ that are less than $K$, otherwise there would probably be no hope of recovering $q$. When $n = k$ it is easy to see that there are an exponential number of roots in $[0, K)$ because any k-wise combination of the roots of $f_i$ for each $i$ corresponds to a unique integer in $\mathbb{Z}_k$ that is a root of $F$. This total number of roots is precisely $\Pi_{i= 1}^k (p_i - 1)/2 \approx K/2^k$. Although the number of solutions for $q$ remaining is still exponential, the information about $q$ that we got from examining the roots of $f_1,...,f_k$ reduced the solution space by a factor $2^k$. Heuristically, we would hope that each polynomial $f_i$ for $i > k$ would continue to reduce the solution space by a factor 2 so that we would only need $n = O(k) = O(log(q))$ polynomials to reduce the number of solutions to a constant. However, proving this seems to be tricky and we are working on a proof. 

\section{Turning the Problem Around} 
Another idea we are working on is to turn this problem around and assume it is hard to factor $p^2q$, and thus that it is hard to find small roots of polynomials of poly degree over a super smooth modulus N and to build some useful crypto primitives like key exchange from this assumption. This problem may also be quantum hard. 

\section{Conclusions and Open Problems}

Since this problem generally reduces to factoring polynomials modulo composites, if time permits, we may survey some of the known factoring algorithms in this space. One such problem is that of factoring polynomials over finite fields, for which polynomial time algorithms exist. Von Zur Gathen and Panario wrote a nice survey~\cite{Gathen} summarizing the main methods for factoring univariate polynomials over finite fields. 



{\footnotesize \bibliographystyle{acm}
\bibliography{project}}


%\theendnotes

\end{document}
